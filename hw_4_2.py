import cProfile


def prime_num_for(i):
    if i < 3:
        return i+1
    k = 2
    num = 3
    while k < i:
        num += 1
        prime = True
        for div in range(2, num):
            if num % div == 0:
                prime = False
                break
        if prime:
            k += 1
    return num


def prime_eratos(i):
    length = i*15
    num_list = [num for num in range(length)]
    num_list[1] = 0
    for prime in num_list:
        if prime:
            for num in range(prime**2, length, prime):
                num_list[num] = 0
    num_list = sorted(list(set(num_list)))
    return num_list[i]


def main():
    i = 500
    prime_eratos(i)
    prime_num_for(i)


cProfile.run('main()')
'''
Для длины списка под решето выбрал коэффициент 15, с коэффициентом 10 перестал работать после i ~ 7000, 
с коэффициентом 15 дошел до i = 300000, всё работает. Понимаю что это чуть лишняя работа для программы, 
но выводить точнее формулу не было желания.

Для i = 500, время работы функции с решетом Эратосфена 0.001, собственного решения в циклах 0.055.

Для i = 1000, время работы функции с решетом Эратосфена 0.004, собственного решения в циклах 0.270.

Для i = 5000, время работы функции с решетом Эратосфена 0.017, собственного решения в циклах 6.485.

Для i = 10000, время работы функции с решетом Эратосфена 0.036, собственного решения в циклах 28.592.

Для i = 20000, время работы функции с решетом Эратосфена 0.076, собственного решения в циклах 123.318.

Для функции с решетом Эратосфена сложность надеюсь O(n\log(\log n)), по крайнер мере время в зависимости от
количества данных меняется не линейно, а для собственного решения в циклах сложность близкая к O(n**2).
'''
